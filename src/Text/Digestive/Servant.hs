{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DefaultSignatures   #-}
module Text.Digestive.Servant where

import           Control.Monad.Except                      (MonadError (throwError),
                                                            MonadIO (..),
                                                            MonadTrans (lift),
                                                            guard)
import           Control.Monad.Trans.Maybe                 (MaybeT (runMaybeT))
import           Data.Functor                              ((<&>))
import           Data.Text                                 (Text)
import qualified Data.Text                                 as T
import qualified Data.Text.Encoding                        as T
import           GHC.TypeLits                              (KnownSymbol, Symbol,
                                                            symbolVal)
import           Servant
import           Servant.Auth.Server
import           Servant.Auth.Server.Internal.AddSetCookie
import           Text.Digestive                            (Env, Form, FormEncType (UrlEncoded),
                                                            FormInput (TextInput),
                                                            View, fromPath,
                                                            getForm, postForm)
import           Text.Digestive.Servant.Cookie             (CookieList,
                                                            HasCookie (..),
                                                            ReqCookie (..),
                                                            ReqCookies)
import           Web.Cookie                                (SetCookie (setCookieValue))
import qualified Web.FormUrlEncoded                        as FE

-- | Monadic wrapper around XSRF cookie settings used for the form. For instance
-- when working with a custom handler such as @ReaderT Enivronment Handler@ you
-- can optionally make cookies insecure for development without HTTPS:
-- > instance (Monad m) => HasFormicSettings (AppT m) where
-- >   formicCookieSettings = ask <&>
-- >     \case
-- >       Production -> defaultCookieSettings
-- >       _          -> defaultCookieSettings { cookieIsSecure = NotSecure }
class HasFormicSettings m where
  formicCookieSettings :: m CookieSettings

  default formicCookieSettings :: Applicative m => m CookieSettings
  formicCookieSettings = pure defaultCookieSettings

-- | An intermediate type representing the usual @runForm@ action with optional
-- XSRF protection.
newtype Formic (name :: Symbol) (v :: *) (m :: * -> *) (a :: *)
  = Formic { runForm :: Form v m a -> Maybe Text -> m (Maybe (View v, Maybe a)) }

-- Validate the form, verifying the XSRF token provided is the same as that
-- given by the hidden input.
instance ( Monad m, KnownSymbol name, MonadError ServerError m)
  => FE.FromForm (Formic name v m a) where
  fromForm f = Right $ Formic $ \ form xsrf -> runMaybeT $ do
    let validToken = rightToMaybe (FE.lookupUnique "xsrf" f) == xsrf
    guard validToken

    let formName = T.pack $ symbolVal $ Proxy @name
    lift $ postForm formName form makeEnv
    where
      makeEnv :: (Monad m) => FormEncType -> m (Env m)
      makeEnv UrlEncoded = return env
      makeEnv _          = return (const $ return [])

      env :: (Monad m) => Env m
      env path = return $ map TextInput $ FE.lookupAll (fromPath path) f

-- | A convenience type synonym for the standard routes generated by
-- @formicServer@.
--
-- > app :: ServerT (FormicRoute "formName" Text Handler (Post '[HMTL] (Html ()))) Handler
-- > app = formicServer ...
type FormicRoute html return name v m a res =
  FormicGet html return :<|>
  ReqBody '[FormUrlEncoded] (Formic name v m a) :> ReqCookies '[ReqCookie "XSRF-TOKEN" XSRFToken] :> res

type FormicGet types return =
  Verb 'GET 200 types (Headers '[ Header "Set-Cookie" SetCookie ] return)

-- | Wrapper around text for cross site forgery token.
newtype XSRFToken = UnsafeXSRFToken { extractXSRFToken :: Text }
  deriving (Eq, Show, FromHttpApiData)

-- | Create two handlers, one get, one post, which handle displaying and
-- validating a form. On get we display the provided View, passing both the
-- default @getView@ from @Text.Digestive@ as well as the @Text@ of a hidden
-- input with the XSRF token. This input must be present in the form.
formicServer
  :: forall m x name v a res cookies html
   . ( Monad m
     , MonadIO m
     , MonadError ServerError m
     , KnownSymbol name
     , Monoid v
     , HasFormicSettings m
     , HasCookie "XSRF-TOKEN" XSRFToken cookies
     , MimeRender html x
     )
  => Form v m a               -- ^ Form to run against inputs
  -> (Text-> View v -> m x)
  -- ^ Function to render view, given a hidden XSFR token input
  -> (a -> m res)       -- ^ Upon successful resolution of route
  -> m (Headers '[Header "Set-Cookie" SetCookie] x) :<|>
    (Formic name v m a -> CookieList cookies -> m res)
formicServer form renderView successAction = getHandler :<|> postHandler
  where
    getHandler = do
      let formName = T.pack $ symbolVal $ Proxy @name
     -- Render Form
      (content, xsrfCookie) <- runViewXSRF =<< getForm formName form

      return $ addHeader xsrfCookie content

    -- A hidden input in the form to render the XSRF
    mkXSRFInput :: SetCookie ->Text
    mkXSRFInput cookie =
      let token = T.decodeUtf8 $ setCookieValue cookie
       in "<input type=\"hidden\" name=\"xsrf\" value\"" <> token <> "\" />"

    -- Generate a view with protection for cross site forgery requests.
    runViewXSRF :: View v -> m (x, SetCookie)
    runViewXSRF v = do
       -- Set XSRF cookie
      xsrfCookie <- liftIO . makeXsrfCookie =<< (formicCookieSettings  <&> \ c ->
        c { cookieXsrfSetting = Just $ defaultXsrfCookieSettings { xsrfHeaderName = "X-XSRF-TOKEN" }
          })
      content <- renderView (mkXSRFInput xsrfCookie) v
      return (content, xsrfCookie)

    -- Handle a post result, running the form, and if it fails, throwing an
    -- error which returns the view re-rendered with errors as well as a xsrf
    -- cookie. If successful we simply run the success action. The use of an
    -- error here follows the notion that the API documents the ideal case, not
    -- that of falsely entered data.
    postHandler formic cookies =
      let token = extractXSRFToken . unReqCookie $ getCookie @"XSRF-TOKEN" cookies
       in runForm formic form (Just token) >>=
      \case
        Nothing -> throwError err400 { errReasonPhrase = "XSRF token invalid!" }
        Just (v, Nothing) -> do
          (content, xsrfCookie) <- runViewXSRF v
          throwError $ ServerError
            { errHTTPCode = 200
            , errReasonPhrase = ""
            , errBody = mimeRender (Proxy @html) content
            , errHeaders = mkHeaders $ SetCookieCons (Just xsrfCookie) SetCookieNil  }
        Just (_, Just a)  -> successAction a

-- Conveniance
rightToMaybe :: Either a b -> Maybe b
rightToMaybe (Left _)  = Nothing
rightToMaybe (Right b) = Just b
